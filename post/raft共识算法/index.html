<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Raft共识算法 | Walker's blog</title><meta name=keywords content><meta name=description content="Raft 共识算法 基本概念 Raft 共识算法算是Paxos的工程化，Raft 为了达到共识一共做了两件事情
问题分解 状态简化 问题分解是将&#34;复制集中节点一致性&#34;这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）
Raft 协议的工作原理
所有节点启动时都是以follower的角色启动的 选举出 leader Leader负责Replicated log的管理 leader 负责所有客户端的请求，然后复制到 follower 节点，并在安全的时执行这些操作 如果遇到 leader 故障，followers会重新选举出新的leader 所有的节点在任何时候会处于三种状态中
followers : 所有的节点在启动时都是 follower状态，如果在一定时间之后follower 没有收到leader的信息，就会自动切换为 candidate 角色然后发起选举并将选举信息推送给其他follower，如果收到 majority 的响应，那么就会切换为leader。 Candidate ： follower 和 leader的中间角色 leader ： 负责处理client的请求，并处理 replicated log的处理，leader 会有任期(term)，在一个term完成 term term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。 任期是递增的，这就充当了逻辑时钟的作用；term 存在的意义，
由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点 B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的 term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份，变为follower 另外 term在选举时也很有意义。 另外，term 还会有一种极端的场景出现，就是脑裂，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。"><meta name=author content="Walker"><link rel=canonical href=https://walkerliu.top/post/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href="https://avatars.githubusercontent.com/u/13366425?s=400&u=e97fc3af556db277bad2b15d582b7e9a0bd31491&v=4"><link rel=icon type=image/png sizes=16x16 href="https://avatars.githubusercontent.com/u/13366425?s=400&u=e97fc3af556db277bad2b15d582b7e9a0bd31491&v=4"><link rel=icon type=image/png sizes=32x32 href="https://avatars.githubusercontent.com/u/13366425?s=400&u=e97fc3af556db277bad2b15d582b7e9a0bd31491&v=4"><link rel=apple-touch-icon href="https://avatars.githubusercontent.com/u/13366425?s=400&u=e97fc3af556db277bad2b15d582b7e9a0bd31491&v=4"><link rel=mask-icon href="https://avatars.githubusercontent.com/u/13366425?s=400&u=e97fc3af556db277bad2b15d582b7e9a0bd31491&v=4"><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Raft共识算法"><meta property="og:description" content="Raft 共识算法 基本概念 Raft 共识算法算是Paxos的工程化，Raft 为了达到共识一共做了两件事情
问题分解 状态简化 问题分解是将&#34;复制集中节点一致性&#34;这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）
Raft 协议的工作原理
所有节点启动时都是以follower的角色启动的 选举出 leader Leader负责Replicated log的管理 leader 负责所有客户端的请求，然后复制到 follower 节点，并在安全的时执行这些操作 如果遇到 leader 故障，followers会重新选举出新的leader 所有的节点在任何时候会处于三种状态中
followers : 所有的节点在启动时都是 follower状态，如果在一定时间之后follower 没有收到leader的信息，就会自动切换为 candidate 角色然后发起选举并将选举信息推送给其他follower，如果收到 majority 的响应，那么就会切换为leader。 Candidate ： follower 和 leader的中间角色 leader ： 负责处理client的请求，并处理 replicated log的处理，leader 会有任期(term)，在一个term完成 term term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。 任期是递增的，这就充当了逻辑时钟的作用；term 存在的意义，
由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点 B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的 term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份，变为follower 另外 term在选举时也很有意义。 另外，term 还会有一种极端的场景出现，就是脑裂，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。"><meta property="og:type" content="article"><meta property="og:url" content="https://walkerliu.top/post/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"><meta property="og:image" content="https://walkerliu.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-02-21T15:32:34+08:00"><meta property="article:modified_time" content="2021-02-21T15:32:34+08:00"><meta property="og:site_name" content="Walker's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://walkerliu.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Raft共识算法"><meta name=twitter:description content="Raft 共识算法 基本概念 Raft 共识算法算是Paxos的工程化，Raft 为了达到共识一共做了两件事情
问题分解 状态简化 问题分解是将&#34;复制集中节点一致性&#34;这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）
Raft 协议的工作原理
所有节点启动时都是以follower的角色启动的 选举出 leader Leader负责Replicated log的管理 leader 负责所有客户端的请求，然后复制到 follower 节点，并在安全的时执行这些操作 如果遇到 leader 故障，followers会重新选举出新的leader 所有的节点在任何时候会处于三种状态中
followers : 所有的节点在启动时都是 follower状态，如果在一定时间之后follower 没有收到leader的信息，就会自动切换为 candidate 角色然后发起选举并将选举信息推送给其他follower，如果收到 majority 的响应，那么就会切换为leader。 Candidate ： follower 和 leader的中间角色 leader ： 负责处理client的请求，并处理 replicated log的处理，leader 会有任期(term)，在一个term完成 term term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。 任期是递增的，这就充当了逻辑时钟的作用；term 存在的意义，
由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点 B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的 term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份，变为follower 另外 term在选举时也很有意义。 另外，term 还会有一种极端的场景出现，就是脑裂，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://walkerliu.top/post/"},{"@type":"ListItem","position":3,"name":"Raft共识算法","item":"https://walkerliu.top/post/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Raft共识算法","name":"Raft共识算法","description":"Raft 共识算法 基本概念 Raft 共识算法算是Paxos的工程化，Raft 为了达到共识一共做了两件事情\n问题分解 状态简化 问题分解是将\u0026quot;复制集中节点一致性\u0026quot;这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）\nRaft 协议的工作原理\n所有节点启动时都是以follower的角色启动的 选举出 leader Leader负责Replicated log的管理 leader 负责所有客户端的请求，然后复制到 follower 节点，并在安全的时执行这些操作 如果遇到 leader 故障，followers会重新选举出新的leader 所有的节点在任何时候会处于三种状态中\nfollowers : 所有的节点在启动时都是 follower状态，如果在一定时间之后follower 没有收到leader的信息，就会自动切换为 candidate 角色然后发起选举并将选举信息推送给其他follower，如果收到 majority 的响应，那么就会切换为leader。 Candidate ： follower 和 leader的中间角色 leader ： 负责处理client的请求，并处理 replicated log的处理，leader 会有任期(term)，在一个term完成 term term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。 任期是递增的，这就充当了逻辑时钟的作用；term 存在的意义，\n由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点 B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的 term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份，变为follower 另外 term在选举时也很有意义。 另外，term 还会有一种极端的场景出现，就是脑裂，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。","keywords":[],"articleBody":"Raft 共识算法 基本概念 Raft 共识算法算是Paxos的工程化，Raft 为了达到共识一共做了两件事情\n问题分解 状态简化 问题分解是将\"复制集中节点一致性\"这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）\nRaft 协议的工作原理\n所有节点启动时都是以follower的角色启动的 选举出 leader Leader负责Replicated log的管理 leader 负责所有客户端的请求，然后复制到 follower 节点，并在安全的时执行这些操作 如果遇到 leader 故障，followers会重新选举出新的leader 所有的节点在任何时候会处于三种状态中\nfollowers : 所有的节点在启动时都是 follower状态，如果在一定时间之后follower 没有收到leader的信息，就会自动切换为 candidate 角色然后发起选举并将选举信息推送给其他follower，如果收到 majority 的响应，那么就会切换为leader。 Candidate ： follower 和 leader的中间角色 leader ： 负责处理client的请求，并处理 replicated log的处理，leader 会有任期(term)，在一个term完成 term term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。 任期是递增的，这就充当了逻辑时钟的作用；term 存在的意义，\n由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点 B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的 term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份，变为follower 另外 term在选举时也很有意义。 另外，term 还会有一种极端的场景出现，就是脑裂，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。\n选举 当一个节点在等待时间内没有收到主节点的心跳信息，它首先将自己保存的 term 增加 1 并进入 Candidate 状态。此时它会先投票给自己，然后并行发送 RequestVote消息给其它所有节点，请求这些节点投票给自己。然后等待直到以下 3 种情形之一发生：\n收到大于一半的票，当选为主节点 有其它节点当选了主节点，此时会收到新的主节点的心跳 过了一段时间后依旧没有当选，此时该节点会尝试开始新一轮选举 对于第一种情形，Candidate 节点需要收到集群中与自己 term 相同的所有节点中大于一半的票数（当然如果节点 term 比自己大，是不会理睬自己的选举消息的）。节点投票时会采取先到先得的原则，对于某个 term，最多投出一票（后面还会再对投票加一些限制）。这样能保证某个 term 中，最多只会产生一个 leader。当一个 Candidate 变成主节点后，它会向其它所有节点发送心跳信息，这样其它的 Candidate 也会变成 Follower。\n第二种情形是在等待投票的过程中，Candidate 收到其它主节点的心跳信息（只有主节点才会向其它节点发心跳），且信息中包含的 term 大于等于自己的 term，则当前节点放弃竞选，进入 Follower 状态。当然，如前所说，如果心跳中的 term 小于自己，则不予理会。\n第三种情形一般发生在多个 Follower 同时触发选举，而各节点的投票被分散了，导致没有 Candidate 能得到多数票。超过投票的等待时间后，节点触发新一轮选举。理论上，选举有可能永远平票，Raft 中由于各个节点的超时时间是随机的，实际上平票不太会永远持续下去。\nSafety 要求 在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。\n衡量一个分布式算法，有许多属性，如\nsafety：nothing bad happens, liveness： something good eventually happens. 在任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。\nraft协议会保证以下属性 Election safety 选举安全性，即任一任期内最多一个leader被选出。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个leader，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。在raft中，两点保证了这个属性：\n一个节点某一任期内最多只能投一票； 只有获得majority投票的节点才会成为leader。 因此，某一任期内一定只有一个leader。\nlog matching 很有意思，log匹配特性， 就是说如果两个节点上的某个log entry的log index相同且term相同，那么在该index之前的所有log entry应该都是相同的。如何做到的？依赖于以下两点\nIf two entries in different logs have the same index and term, then they store the same command. If two entries in different logs have the same index and term, then the logs are identical in all preceding entries. 首先，leader在某一term的任一位置只会创建一个log entry，且log entry是append-only。其次，consistency check。leader在AppendEntries中包含最新log entry之前的一个log 的term和index，如果follower在对应的term index找不到日志，那么就会告知leader不一致。\n在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得负责。比如下图 注意：上图的a-f不是6个follower，而是某个follower可能存在的六个状态\nleader、follower都可能crash，那么follower维护的日志与leader相比可能出现以下情况\n比leader日志少，如上图中的ab 比leader日志多，如上图中的cd 某些位置比leader多，某些日志比leader少，如ef（多少是针对某一任期而言） 当出现了leader与follower不一致的情况，leader强制follower复制自己的log\nTo bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point.\nleader会维护一个nextIndex[]数组，记录了leader可以发送每一个follower的log index，初始化为eader最后一个log index加1， 前面也提到，leader选举成功之后会立即给所有follower发送AppendEntries RPC（不包含任何log entry， 也充当心跳消息）,那么流程总结为：\ns1 leader 初始化nextIndex[x]为 leader最后一个log index + 1 s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1] s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 false，否则返回True s4 leader收到follower的恢复，如果返回值是True，则nextIndex[x] -= 1, 跳转到s2. 否则 s5 同步nextIndex[x]后的所有log entries\nleader completeness vs elcetion restriction leader完整性：如果一个log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高term的leader的日志里面。这个跟leader election、log replication都有关。\n一个日志被复制到majority节点才算committed 一个节点得到majority的投票才能成为leader，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧。下面的引文指处了如何判断日志的新旧 voter denies its vote if its own log is more up-to-date than that of the candidate.\nIf the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.\n上面两点都提到了majority：commit majority and vote majority，根据Quorum，这两个majority一定是有重合的，因此被选举出的leader一定包含了最新的committed的日志。\nraft与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证leade包含最新的已提交的日志，因此leader不会从follower catchup日志，这也大大简化了系统的复杂度。\nReference Raft 论文\nConsul共识\n最好的Raft讲解，没有之一\n参考1\n","wordCount":"354","inLanguage":"en","datePublished":"2021-02-21T15:32:34+08:00","dateModified":"2021-02-21T15:32:34+08:00","author":{"@type":"Person","name":"Walker"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://walkerliu.top/post/raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"Walker's blog","logo":{"@type":"ImageObject","url":"https://avatars.githubusercontent.com/u/13366425?s=400\u0026u=e97fc3af556db277bad2b15d582b7e9a0bd31491\u0026v=4"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://walkerliu.top accesskey=h title="Home (Alt + H)"><img src=https://s4.ax1x.com/2022/02/02/HAJgLF.jpg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://walkerliu.top/categories/ title=categories><span>categories</span></a></li><li><a href=https://walkerliu.top/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://walkerliu.top>Home</a>&nbsp;»&nbsp;<a href=https://walkerliu.top/post/>Posts</a></div><h1 class=post-title>Raft共识算法</h1><div class=post-meta><span title='2021-02-21 15:32:34 +0800 +0800'>February 21, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Walker&nbsp;|&nbsp;<a href=https://github.com/WalkerLiuFei/WalkerLiuFei.github.io/content/post/Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=raft-共识算法>Raft 共识算法<a hidden class=anchor aria-hidden=true href=#raft-共识算法>#</a></h1><h2 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h2><p>Raft 共识算法算是Paxos的工程化，Raft 为了达到共识一共做了两件事情</p><ul><li>问题分解</li><li>状态简化</li></ul><p>问题分解是将"复制集中节点一致性"这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，<strong>leader election</strong>， <strong>log replication</strong>，<strong>safety</strong>，<strong>membership changes</strong>。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）</p><p>Raft 协议的工作原理</p><ol><li>所有节点启动时都是以follower的角色启动的</li><li>选举出 leader</li><li>Leader负责Replicated log的管理</li><li>leader 负责所有客户端的请求，然后复制到 follower 节点，并在<strong>安全</strong>的时执行这些操作</li><li>如果遇到 leader 故障，followers会重新选举出新的leader</li></ol><p>所有的节点在任何时候会处于三种状态中</p><ul><li>followers : 所有的节点在启动时都是 follower状态，如果在一定时间之后follower 没有收到leader的信息，就会自动切换为 candidate 角色然后发起选举并将选举信息推送给其他follower，如果收到 majority 的响应，那么就会切换为leader。</li><li>Candidate ： follower 和 leader的中间角色</li><li>leader ： 负责处理client的请求，并处理 replicated log的处理，leader 会有任期(term)，在一个<code>term</code>完成</li></ul><p><img loading=lazy src=https://img2018.cnblogs.com/blog/1089769/201812/1089769-20181216202049306-1194425087.png alt=img></p><h3 id=term>term <a hidden class=anchor aria-hidden=true href=#term>#</a></h3><p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。 任期是递增的，这就充当了逻辑时钟的作用；term 存在的意义，</p><ol><li>由于网络情况不佳，一个主节点 A 与其它节点失联，其它节点选了一个新的主节点 B，当网络恢复正常时，旧主节点 A 收到主节点 B 的消息时，它会判断新主节点 B 的 term 大于自己，说明自己错过了一些事件，因此选择放弃自己的主节点身份，变为follower</li><li>另外 term在选举时也很有意义。</li></ol><p>另外，term 还会有一种极端的场景出现，就是脑裂，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种<em>split vote</em>的情况。</p><h3 id=选举>选举<a hidden class=anchor aria-hidden=true href=#选举>#</a></h3><p>当一个节点在等待时间内没有收到主节点的心跳信息，它首先将自己保存的 term 增加 <code>1</code> 并进入 Candidate 状态。此时它会先投票给自己，然后并行发送 <code>RequestVote</code>消息给其它所有节点，请求这些节点投票给自己。然后等待直到以下 3 种情形之一发生：</p><ol><li>收到大于一半的票，当选为主节点</li><li>有其它节点当选了主节点，此时会收到新的主节点的心跳</li><li>过了一段时间后依旧没有当选，此时该节点会尝试开始新一轮选举</li></ol><p>对于第一种情形，Candidate 节点需要收到集群中与自己 term 相同的所有节点中大于一半的票数（<strong>当然如果节点 term 比自己大，是不会理睬自己的选举消息的</strong>）。节点投票时会采取先到先得的原则，对于某个 term，最多投出一票（后面还会再对投票加一些限制）。这样能保证某个 term 中，最多只会产生一个 leader。当一个 Candidate 变成主节点后，它会向其它所有节点发送心跳信息，这样其它的 Candidate 也会变成 Follower。</p><p>第二种情形是在等待投票的过程中，Candidate 收到其它主节点的心跳信息（只有主节点才会向其它节点发心跳），且信息中包含的 term 大于等于自己的 term，则当前节点放弃竞选，进入 Follower 状态。当然，如前所说，<strong>如果心跳中的 term 小于自己，则不予理会。</strong></p><p>第三种情形一般发生在多个 Follower 同时触发选举，而各节点的投票被分散了，导致没有 Candidate 能得到多数票。超过投票的等待时间后，节点触发新一轮选举。<strong>理论上，选举有可能永远平票，Raft 中由于各个节点的超时时间是随机的，实际上平票不太会永远持续下去。</strong></p><h2 id=safety-要求>Safety 要求<a hidden class=anchor aria-hidden=true href=#safety-要求>#</a></h2><p>  在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。</p><p>  衡量一个分布式算法，有许多属性，如</p><ul><li>safety：nothing bad happens,</li><li>liveness： something good eventually happens.</li></ul><p>  在任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。</p><p>  raft协议会保证以下属性
<img loading=lazy src=https://img2018.cnblogs.com/blog/1089769/201812/1089769-20181216202333639-30919755.png alt=img></p><h3 id=election-safety>Election safety<a hidden class=anchor aria-hidden=true href=#election-safety>#</a></h3><p>  选举安全性，即任一任期内最多一个leader被选出。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个leader，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。在raft中，两点保证了这个属性：</p><ul><li>一个节点某一任期内最多只能投一票；</li><li>只有获得majority投票的节点才会成为leader。</li></ul><p>  因此，<strong>某一任期内一定只有一个leader</strong>。</p><h3 id=log-matching>log matching<a hidden class=anchor aria-hidden=true href=#log-matching>#</a></h3><p>  很有意思，log匹配特性， 就是说如果两个节点上的某个log entry的log index相同且term相同，那么在该index之前的所有log entry应该都是相同的。如何做到的？依赖于以下两点</p><ul><li>If two entries in different logs have the same index and term, then they store the same command.</li><li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.</li></ul><p>  首先，leader在某一term的任一位置只会创建一个log entry，且log entry是append-only。其次，consistency check。leader在AppendEntries中包含最新log entry之前的一个log 的term和index，如果follower在对应的term index找不到日志，那么就会告知leader不一致。</p><p>  在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得负责。比如下图<img loading=lazy src=https://img2018.cnblogs.com/blog/1089769/201812/1089769-20181216202408734-1760694063.png alt=img></p><p>  <strong>注意</strong>：上图的a-f不是6个follower，而是某个follower可能存在的六个状态</p><p>  leader、follower都可能crash，那么follower维护的日志与leader相比可能出现以下情况</p><ul><li>比leader日志少，如上图中的ab</li><li>比leader日志多，如上图中的cd</li><li>某些位置比leader多，某些日志比leader少，如ef（多少是针对某一任期而言）</li></ul><p>  当出现了leader与follower不一致的情况，leader强制follower复制自己的log</p><blockquote><p>To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point.</p></blockquote><p>  leader会维护一个nextIndex[]数组，记录了leader可以发送每一个follower的log index，初始化为eader最后一个log index加1， 前面也提到，leader选举成功之后会立即给所有follower发送AppendEntries RPC（不包含任何log entry， 也充当心跳消息）,那么流程总结为：</p><blockquote><p>s1 leader 初始化nextIndex[x]为 leader最后一个log index + 1
s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1]
s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 false，否则返回True
s4 leader收到follower的恢复，如果返回值是True，则nextIndex[x] -= 1, 跳转到s2. 否则
s5 同步nextIndex[x]后的所有log entries</p></blockquote><h3 id=leader-completeness-vs-elcetion-restriction>leader completeness vs elcetion restriction<a hidden class=anchor aria-hidden=true href=#leader-completeness-vs-elcetion-restriction>#</a></h3><p>  leader完整性：如果一个log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高term的leader的日志里面。这个跟leader election、log replication都有关。</p><ul><li>一个日志被复制到majority节点才算committed</li><li>一个节点得到majority的投票才能成为leader，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧。下面的引文指处了如何判断日志的新旧</li></ul><blockquote><p>voter denies its vote if its own log is more up-to-date than that of the candidate.</p></blockquote><blockquote><p>If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</p></blockquote><p>  上面两点都提到了majority：commit majority and vote majority，根据Quorum，这两个majority一定是有重合的，因此被选举出的leader一定包含了最新的committed的日志。</p><p>  raft与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证leade包含最新的已提交的日志，因此leader不会从follower catchup日志，这也大大简化了系统的复杂度。</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p><a href=https://raft.github.io/raft.pdf>Raft 论文</a></p><p><a href=https://www.consul.io/docs/internals/consensus.html>Consul共识</a><br><a href=http://thesecretlivesofdata.com/raft/>最好的Raft讲解，没有之一</a></p><p><a href=https://www.cnblogs.com/mindwind/p/5231986.html>参考1</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://walkerliu.top/post/http-status-code-%E5%90%AB%E4%B9%89%E5%8F%8A%E5%BA%94%E7%94%A8part-i/><span class=title>« Prev</span><br><span>HTTP Status Code 含义及适用场景(Part I)</span></a>
<a class=next href=https://walkerliu.top/post/%E4%BD%BF%E7%94%A8-hugo-+-typora-+-github-action-%E5%AE%8C%E7%BE%8E%E5%8D%9A%E5%AE%A2/><span class=title>Next »</span><br><span>使用 Hugo + Typora + Github Action 完美博客</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Raft共识算法 on twitter" href="https://twitter.com/intent/tweet/?text=Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95&url=https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Raft共识算法 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f&title=Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95&summary=Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95&source=https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Raft共识算法 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f&title=Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Raft共识算法 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Raft共识算法 on whatsapp" href="https://api.whatsapp.com/send?text=Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95%20-%20https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Raft共识算法 on telegram" href="https://telegram.me/share/url?text=Raft%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95&url=https%3a%2f%2fwalkerliu.top%2fpost%2fraft%25E5%2585%25B1%25E8%25AF%2586%25E7%25AE%2597%25E6%25B3%2595%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://walkerliu.top>Walker's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>