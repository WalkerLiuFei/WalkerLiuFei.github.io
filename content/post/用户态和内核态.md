---
title: "用户态和内核态"
date: 2023-02-21T13:26:06+08:00
draft: false
math: true
---

## 定义

内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。

用户态：**只能受限的访问内存**，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

**为什么要有用户态和内核态？**

1. 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。

## 用户态和内核态的切换

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.

这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令

这种机制叫**系统调用**, 在CPU中的实现称之为**陷阱指令**(Trap Instruction) 并且用户模式和系统模式之间的转换是由操作系统通过系统调用或中断来控制的。

他们的工作流程如下:

1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.
2. 用户态程序执行陷阱指令
3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问
4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务
5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果

当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。

当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。

## 系统调用开销大

平时说的系统调用开销大，主要是相对于函数调用来说的。

一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作**“保护模式”**)

对于一个函数调用，汇编层面上就是一个CALL或者JMP，这种指令在硬件层面上虽然首次是会打乱流水线的，但如果是十分有规律的情况下，大多数CPU都能很好的处理。

## 锁开销和上下文切换开销

### 互斥锁的开销主要在内核态与用户态的切换

申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切换）；没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换）；被唤醒进程在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内核态的切换。同时，其他竞争锁的进程在这个过程中也要进行一次切换。

**进程上下文切换的直接消耗包括CPU寄存器保存和加载，需要调度时有内核调度代码的执行。**

### 上下文切换开销

进程切换

**进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。　这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器 的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。那么被中止运行进程的中间数据存在何处好呢？当然这个地方应该是进程的 私有堆栈。**

让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。

调度器进程切换的代码应有如下功能：

●保存处理器PC寄存器的值到被中止进程的私有堆栈；

●保存处理器PSW寄存器的值到被中止进程的私有堆栈；

●保存处理器SP寄存器的值到被中止进程的进程控制块；

●保存处理器其他寄存器的值到被中止进程的私有堆栈；

●自待运行进程的进程控制块取SP值并存入处理器的寄存器SP；

●自待运行进程的私有堆栈恢复处理器各寄存器的值；

●自待运行进程的私有堆栈中弹出PSW值并送入处理器的PSW；

●自待运行进程的私有堆栈中弹出PC值并送入处理器的PC。