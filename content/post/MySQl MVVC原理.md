---
title: "MySQl MVVC原理及其Trade-off"
date: 2021-05-21T16:05:52+08:00
draft: true
---

## 事务隔离级别

MySQL的事务隔离级别默认是`REAPTABLE READ` 也就是可重复读，意思是指在一个事务内读取一条数据从开始到结束是完全一致的。相对应的, `COMMITED READ` 指的是读到的数据是最新，已经`COMMMITED`的数据。

### undo log

undo log包含撤消日志，这些记录是包含有关如何撤消事务对聚集索引记录的最新更改的信息的记录集合。它们包含有指定Row的信息和版本好，undo log不仅仅是在`DML` 时会进行更新。 在一个只有读操作的Transaction结束后同样会进行更新。因为undo log包含有历史数据，那他们在`reaptable read` 隔离级别下，只能在没有更低TRX ID的事务运行时会Discard log。这也是为什么MySQL官方文档建议我们在使用MySQL时尽量保证事务的执行市场要短，不要包含有IO操作的原因之一。



## 实现原理

简单的说，MySQL在执行每一条事务或者说 `DML` 之前都是有一个事务编号的，或者说叫`Transaction ID` ，同样，`MySQL` 中的每条`Row`也是有相对应的隐藏字段，他们分别是

1. 一个 6 字节的 `DB_TRX_ID` 字段指示插入或更新该行的最后一个事务的`TRX_ID`。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已删除。
2. 一个 7 字节的 `DB_ROLL_PTR` 字段称为滚动指针。回滚指针指向一条写入回滚段的撤销日志记录。如果该行已更新，则撤消日志记录包含在更新之前重建该行内容所需的信息。
3. 一个 6 字节的 `DB_ROW_ID` 字段包含一个行 ID，该行 ID 在插入新行时单调增加。如果 InnoDB 自动生成聚簇索引，则该索引包含行 ID 值。否则，`DB_ROW_ID` 列不会出现在任何索引中。

当你删除一条Row的时候，它并不会立即被被InnoDB从磁盘中物理删除，而是等到所有读取这条Row的Transaction执行完毕，Undo Log中不再存在这条数据对应的undo log日志，它才会从磁盘中被物理删除



那么MVVC机制对索引的影响呐？ Cluster Index因为包含了指定的数据所以可以原地更新，但是二级所以做不到。 所以二级索引更新的步骤是

1. 当二级索引列被更新时，久的在B+树中的record被标记为deleted，新的record被插入索引树，久的二级索引记录最终从索引树中被清除
2. 当一个二级索引记录被标记为删除时，并且这个被标记被删除的二级索引被一个更新的事务操作了，InnoDB 从聚簇索引中拿到record，拿到这个record中指向的 DB_TRX_ID，并检查，如果记录在读取事务启动后被修改，则从撤消日志中检索记录的正确版本。

从上可以知道，

1. 在MVVC中，每次事务的操作都会创建一个新版本，因此在读取二级索引时需要考虑到并发控制中的可见性问题。在读取二级索引时，需要查询到所有可见的版本，而不仅仅是最新的版本。因此，在读取二级索引时需要耗费更多的时间。
2. MVVC会创建多个版本的数据，而每个版本的数据都需要维护自己的索引。因此，MVVC会占用更多的存储空间。在使用MVVC时，需要考虑到这一点，以确保数据库的存储空间足够。



## Reference

1. [InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)

